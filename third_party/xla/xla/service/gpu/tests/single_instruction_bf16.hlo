// RUN: hlo-opt %s --platform=gpu --stage=ptx --xla_gpu_target_config_filename=%S/../../../tools/hlo_opt/gpu_specs/h100_sxm.txtpb --split-input-file | FileCheck %s --check-prefixes=CHECK-SM90

// CHECK-SM90: add.rn.bf16

HloModule Test, is_scheduled=true

fused_computation {
  param_0 = bf16[] parameter(0)
  param_1 = bf16[] parameter(1)
  ROOT b.1 = bf16[] add(bf16[] param_0, bf16[] param_1)
}

ENTRY main {
  a = bf16[] parameter(0)
  b = bf16[] parameter(1)
  ROOT wrapped_b = bf16[] fusion(bf16[] a, bf16[] b), kind=kLoop, calls=fused_computation
}

// -----

// CHECK-SM90: sub.rn.bf16

HloModule Test, is_scheduled=true

fused_computation {
  param_0 = bf16[] parameter(0)
  param_1 = bf16[] parameter(1)
  ROOT b.1 = bf16[] subtract(bf16[] param_0, bf16[] param_1)
}

ENTRY main {
  a = bf16[] parameter(0)
  b = bf16[] parameter(1)
  ROOT wrapped_b = bf16[] fusion(bf16[] a, bf16[] b), kind=kLoop, calls=fused_computation
}

// -----

// CHECK-SM90: mul.rn.bf16

HloModule Test, is_scheduled=true

fused_computation {
  param_0 = bf16[] parameter(0)
  param_1 = bf16[] parameter(1)
  ROOT b.1 = bf16[] multiply(bf16[] param_0, bf16[] param_1)
}

ENTRY main {
  a = bf16[] parameter(0)
  b = bf16[] parameter(1)
  ROOT wrapped_b = bf16[] fusion(bf16[] a, bf16[] b), kind=kLoop, calls=fused_computation
}

// -----

// CHECK-SM90: min.NaN.bf16

HloModule Test, is_scheduled=true

fused_computation {
  param_0 = bf16[] parameter(0)
  param_1 = bf16[] parameter(1)
  ROOT b.1 = bf16[] minimum(bf16[] param_0, bf16[] param_1)
}

ENTRY main {
  a = bf16[] parameter(0)
  b = bf16[] parameter(1)
  ROOT wrapped_b = bf16[] fusion(bf16[] a, bf16[] b), kind=kLoop, calls=fused_computation
}

// -----

// CHECK-SM90: max.NaN.bf16

HloModule Test, is_scheduled=true

fused_computation {
  param_0 = bf16[] parameter(0)
  param_1 = bf16[] parameter(1)
  ROOT b.1 = bf16[] maximum(bf16[] param_0, bf16[] param_1)
}

ENTRY main {
  a = bf16[] parameter(0)
  b = bf16[] parameter(1)
  ROOT wrapped_b = bf16[] fusion(bf16[] a, bf16[] b), kind=kLoop, calls=fused_computation
}

// -----

// CHECK-SM90: max.NaN.bf16
// CHECK-SM90: min.NaN.bf16

HloModule Test, is_scheduled=true

fused_computation {
  param_0 = bf16[] parameter(0)
  param_1 = bf16[] parameter(1)
  param_2 = bf16[] parameter(2)
  ROOT b.1 = bf16[] clamp(bf16[] param_0, bf16[] param_1, bf16[] param_2)
}

ENTRY main {
  a = bf16[] parameter(0)
  b = bf16[] parameter(1)
  c = bf16[] parameter(2)
  ROOT wrapped_b = bf16[] fusion(bf16[] a, bf16[] b, bf16[] c), kind=kLoop, calls=fused_computation
}

// -----

// CHECK-SM90: neg.bf16

HloModule Test, is_scheduled=true

fused_computation {
  param_0 = bf16[] parameter(0)
  ROOT b.1 = bf16[] negate(bf16[] param_0)
}

ENTRY main {
  a = bf16[] parameter(0)
  ROOT wrapped_b = bf16[] fusion(bf16[] a), kind=kLoop, calls=fused_computation
}
